---
title: "Vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, include = FALSE}
if(FALSE){
  makeReadMe <- function(){
    library(readr)
    fileName <- "../vignettes/vignette.Rmd"
    content <- readChar(fileName, file.info(fileName)$size)
    content <- gsub("---.+?---","",content)
    content <- gsub("^(\r\n)+","",content)
    content <- gsub("([a-zA-Z_]+)\\.jpg","vignettes/\\1.jpg",content)
    write_file(content, file="../README.md")
  }
  knitr::knit("vignette.Rmd", output = "../vignettes/vignette.md")
  file.rename("../vignettes/vignette.md", "../vignettes/vignette.Rmd")
  makeReadMe()
}
library(rdaemon)
```

## Introduction
R is a single process language that is designed for interactively used by the user. However, there are some special cases that we might need a daemon process running in the background. Using the other programming languages is an option, but it also require our experience in the other languages. `rdaemon` is a package which is specifically designed for using R as a daemon process. With `rdaemon`, the user can easily start a daemon process using R function. The package is able to run one or many daemon from a single R session, each daemon can be uniquely identified by a daemon name. The daemon will keep running even after the R session quits. Therefore, it is user's responsibility to quit the daemon after using it.

The daemon organizes user's code using the task. A task is combination of the R expression and its running environment and will be run repeatively by the daemon. A daemon can have one or more tasks. The tasks are distinguished by the task ID. Below are the diagram for the daemon

![](daemon_structure.jpg)
Note that when multiple tasks are in the same daemon, the daemon will run them sequentially. Therefore, it is recommended to make each task relatively simple if many tasks exist in the same daemon. Otherwise a long-running task might block the execution of the other tasks.

Each R process can starts one or more daemons depending on user's needs. Therefore, it is possible to start two daemons from an R process, where the former is responsible for some simple tasks and the latter can do a long-running task.

In this vignette, we will first cover the basic use case, and then talks about the method to optimize the daemon speed.

## Basic usage
### Start a daemon
For starting a new daemon or connecting with an existing daemon, you can simple run
```{r}
registerDaemon(daemonName = "vignetteDaemon")
```
This will start a daemon named `vignetteDaemon` if the daemon does not exist. Note that if you do not provide the daemon name, a default name will be used which is unique for each R process. In other words, unless you explicitly use the same daemon name, the first call of `registerDaemon()` will always start a new daemon for the current R session by default.


### Set the daemon task
As we stated in the introduction, the daemon organize user's code using the task. The task can be set via `daemonSetTask()`. For example
```{r}
## Set the task expression and environment for the task with the ID "task1"
## in the daemon named "vignetteDaemon"
daemonSetTask(expr = message(a), 
              exports = list(a = 1),
              taskId = "task1")

## Wait and collect the daemon log to see the output
Sys.sleep(1)
daemonLogs()
```
The package can memorize the last registered daemon. Therefore you do not have to explicitly provide the daemon name after `registerDaemon()`. Likewise, the task ID will also be recorded and used in the subsequent calls after `daemonSetTask()`.

You can also explicitly export some variables to the task after `daemonSetTask()`
```{r}
daemonExport(b = 2)
```

By default, the task will be run once per second. You can also increase/decrease its frequence by passing the argument `interval` to `daemonSetTask()` or calling `daemonSetTaskInterval()`
```{r}
## Run the task once per 2 seconds
daemonSetTaskInterval(interval = 2)
```

The task expression can be retrieved by 
```{r}
daemonGetTask()
```

There is no function to directly get the task environment, but you can get the variable in the task environment by evaluating an expression in the environment
```{r}
daemonEval(a)
```

### Deregister or kill the daemon
To close the connection to the daemon, simply run
```{r}
deregisterDaemon()
```
By default, this will remove the task `task1` as well. However, you can left the task running while close the connection by passing `deleteTask = TRUE` to `deregisterDaemon()`

To kill the daemon, run
```{r}
killDaemon()
```
This will terminate the daemon process.

### Debugging the task
The task expression can be get by `daemonGetTask()` and the daemon log can be obtained by `daemonLogs()`. You can run `daemonEval()` to evaluate an expression under the task environment to see if your code is working in the daemon.


## Optimizing daemon speed
Since the daemon is actually an R process, and R process is relatively heavy , each process can consume about 50MB memory in the system. The overhead might look trivial for a single daemon, but it becomes more serious as the number of daemon increases. For reducing the burden, if the daemon name can be given beforehand, multiple R processes can talk with the same daemon using the same daemon name. For example, we can run the code below in both R session 1 and 2 to connect with the same daemon
```{r, eval=FALSE}
registerDaemon(daemonName = "commonName")
```
Therefore, an R session can connect with one or more daemons, a daemon can be connected with one or more R sessions as well. This gives the developer much flexibility to design their daemon structure and reduces the number of daemons required by the program.

## Session info
```{r}
sessionInfo()
```
